<!DOCTYPE html>
<html>
  <head>
    <title>canvas tutorial</title>
    <style>
      #canvas {
        background: #666;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="640" height="480"></canvas>
    <script>
      var canvas = document.getElementById("canvas");
      var ctx = canvas.getContext("2d")
      var roi_polygon_pos_list = [];
      var is_roi_polygon_closed = true;
      var roi_point_index = null;
      var clicked = false; //　ダブルクリックの判定に使う

      function onSingleLeftClick(e){
        console.log("left single clicked")
        var offsetX = e.offsetX; // =>要素左上からのx座標
        var offsetY = e.offsetY; // =>要素左上からのy座標
        
        if (is_roi_polygon_closed) {  // ポリゴンが閉じていた場合，新しいポリゴンの始点を選択する．
          if (roi_point_index==null) { // 既存の点が選択されていない場合
            is_roi_polygon_closed = false;
            roi_polygon_pos_list = []; // リストの初期化
            roi_polygon_pos_list.push({"x":offsetX, "y":offsetY})
          } else { // 既存の点が選択されている場合
            roi_polygon_pos_list[roi_point_index]["x"] = offsetX
            roi_polygon_pos_list[roi_point_index]["y"] = offsetY
            roi_point_index = null; // 選択が終了
          }
        } else { // 閉じていなかった場合，新しく点を追加
          roi_polygon_pos_list.push({"x":offsetX, "y":offsetY})
        }
      }

      function calculate_point_distance(point_dict1, point_dict2) { // 二点の距離計算
        return Math.sqrt((point_dict1["x"]-point_dict2["x"])**2+(point_dict1["y"]-point_dict2["y"])**2)
      }

      function calculate_point_line_distance(line_point_dict1, line_point_dict2, point_dict) { // 二点を通る直線とある点の距離
        var num = Math.abs(
          (line_point_dict1["x"]-point_dict["x"]) * (line_point_dict2["y"]-point_dict["y"]) +
          (line_point_dict2["x"]-point_dict["x"]) * (line_point_dict1["y"]-point_dict["y"])
        )
        var den = Math.sqrt((line_point_dict2["x"]-line_point_dict1["x"])**2+(line_point_dict2["y"]-line_point_dict1["y"])**2)
        return num/den
      }

      function calculate_line_segment_leg(line_point_dict1, line_point_dict2, point_dict) {// 垂線の足の座標を求める
        var C_num = (point_dict["x"]-line_point_dict1["x"])*(line_point_dict2["x"]-line_point_dict1["x"]) 
        + (point_dict["y"]-line_point_dict1["y"])*(line_point_dict2["y"]-line_point_dict1["y"]);
        var C_den = (line_point_dict2["x"]-line_point_dict1["x"])**2 + (line_point_dict2["y"]-line_point_dict1["y"])**2
        var leg_x = line_point_dict1["x"] + C_num/C_den*(line_point_dict2["x"]-line_point_dict1["x"])
        var leg_y = line_point_dict1["y"] + C_num/C_den*(line_point_dict2["y"]-line_point_dict1["y"])
        return {"x":leg_x, "y":leg_y}
      }

      function onRightClick(e){
        console.log("right clicked")
        var offsetX = e.offsetX; // =>要素左上からのx座標
        var offsetY = e.offsetY; // =>要素左上からのy座標

        var pos_dict = {"x":offsetX, "y":offsetY}
        var min_distance = null;
        var min_distance_index = null;

        // 距離の最小となる点を求める
        for (var index in roi_polygon_pos_list) {
          var one_point = roi_polygon_pos_list[index]
          if (index==0) {
            min_distance = calculate_point_distance(pos_dict, one_point);
            min_distance_index = 0;
          } else {
            var distance = calculate_point_distance(pos_dict, one_point);
            if (distance<min_distance) {
              min_distance = distance
              min_distance_index = index
            }
          }
        }

        console.log("min_distance_index:",min_distance_index)

        if (is_roi_polygon_closed) { // ポリゴンが閉じていた場合
          if (min_distance_index!=null) {
            roi_point_index = min_distance_index
          } else {
            roi_point_index = null;
          }
        } else { // ポリゴンが閉じていない場合
          if (min_distance_index==0) {  // ポリゴンがうまくとじる
            roi_polygon_pos_list.push(roi_polygon_pos_list[0])
            is_roi_polygon_closed = true;
            roi_point_index = null;
          } else {
            roi_point_index = null;
          }
        }
        return false; // 右クリック特有の処理
      }

      function onDoubleLeftClick(e) {
        console.log("left double clicked")
        var offsetX = e.offsetX; // =>要素左上からのx座標
        var offsetY = e.offsetY; // =>要素左上からのy座標

        var pos_dict = {"x":offsetX, "y":offsetY}
        var min_point_line_distance = null;
        var min_point_line_distance_index = null; // 2点の最初の方
        // 連続する2点との距離の和が最小となる最初の点を求める
        for (let index=0; index<roi_polygon_pos_list.length; index++) {
          if (index==0) { // 最初の場合
            var one_point = roi_polygon_pos_list[index]
            var two_point = roi_polygon_pos_list[index+1]
            // 垂線の足を求める
            var leg_point = calculate_line_segment_leg(one_point, two_point, pos_dict);
            if ( 
              (Math.min(one_point["x"],one_point["x"]) <= leg_point["x"] && Math.min(one_point["y"],one_point["y"]) <= leg_point["y"]) &&
              (leg_point["x"] <= Math.max(one_point["x"],one_point["x"])  && leg_point["y"] <= Math.max(one_point["y"],one_point["y"]))
            ) { // 垂線の足が線分内にある時
              min_point_line_distance = calculate_point_line_distance(one_point, two_point, pos_dict); // 点と直線の距離
            } else {
              var half_point = {"x":(one_point["x"]+two_point["x"])/2, "y":(one_point["y"]+two_point["y"])/2}; // 辺の中心点
              min_point_line_distance = calculate_point_distance(half_point, pos_dict); // 点と辺の中心点との距離
            }
            min_point_line_distance_index = 0;
          } else　if (index!=(roi_polygon_pos_list.length-1)) {
              var one_point = roi_polygon_pos_list[index]
              var two_point = roi_polygon_pos_list[index+1]

              // 垂線の足を求める
              var leg_point = calculate_line_segment_leg(one_point, two_point, pos_dict);
              if ( 
                (Math.min(one_point["x"],one_point["x"]) <= leg_point["x"] && Math.min(one_point["y"],one_point["y"]) <= leg_point["y"]) &&
                (leg_point["x"] <= Math.max(one_point["x"],one_point["x"])  && leg_point["y"] <= Math.max(one_point["y"],one_point["y"]))
              ) { // 垂線の足が線分内にある時
                var point_line_distance = calculate_point_line_distance(one_point, two_point, pos_dict); // 点と直線の距離
              } else {
                var half_point = {"x":(one_point["x"]+two_point["x"])/2, "y":(one_point["y"]+two_point["y"])/2}; // 辺の中心点
                var point_line_distance = calculate_point_distance(half_point, pos_dict);// 点と辺の中心点との距離
              }                
              
              if (point_line_distance<min_point_line_distance) {
                min_point_line_distance = point_line_distance
                min_point_line_distance_index = index
              }
          }
        }

        if (is_roi_polygon_closed) { // ポリゴンが閉じている場合
          if (min_point_line_distance_index!=null) {
            roi_polygon_pos_list.splice(min_point_line_distance_index+1, 0, pos_dict) // insert
            roi_point_index = min_point_line_distance_index+1
          }
        }
      }

      function onLeftClick(e){
        if (is_roi_polygon_closed) { // ポリゴンが閉じている場合
          // クリックフラグが立っている状態でのクリック
          //     -> ダブルクリック
          if (clicked) {
            clicked = false;
            console.log("double click in func")
            onDoubleLeftClick(e);
            return;
          }
          // シングルクリックを受理、300ms間だけダブルクリック判定を残す
          clicked = true;
          setTimeout(function () {
              // ダブルクリックによりclickedフラグがリセットされていない
              //     -> シングルクリックだった
              if (clicked) {
                  onSingleLeftClick(e);
              }
              clicked = false;
          }, 300);
        } else { //  ポリゴンが閉じていない場合
          onSingleLeftClick(e);
          clicked=false;
        }
      }

      function clear_canvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height)
      }


      function draw_polygon(offset_x, offset_y){
        if (is_roi_polygon_closed) { // ポリゴンが閉じている場合
          var counter = 0
          ctx.beginPath();
          for (var index in roi_polygon_pos_list) {
            var point_dict = roi_polygon_pos_list[index]
            if (counter==0){  // 最初の点のみ
              if (counter==roi_point_index && offset_x!=null && offset_y!=null) { // 選択している点だった場合
                ctx.moveTo(
                  offset_x,
                  offset_y,
                );
              } else {
                ctx.moveTo(
                  point_dict["x"],
                  point_dict["y"]
                );
              }
            } else if(counter!=(roi_polygon_pos_list.length-1)) {  // 最初の点・最後の点(最初の点と同じ)以外
              if (counter==roi_point_index && offset_x!=null && offset_y!=null) { // 選択している点だった場合
                ctx.lineTo(
                  offset_x,
                  offset_y,
                );
              } else {
                ctx.lineTo(
                  point_dict["x"],
                  point_dict["y"]
                );
              }
            }
            counter ++;
          }
          ctx.closePath();
          if (roi_point_index==null) { // ポリゴンが確定している場合のみ描画
            ctx.fillStyle = "red";
            ctx.globalAlpha = 0.5;
            ctx.fill();
          } else {
            ctx.strokeStyle = "orange";
            ctx.stroke();
          }
        } else {
          var counter = 0
          ctx.beginPath();
          for (var index in roi_polygon_pos_list) {
            point_dict = roi_polygon_pos_list[index]
            if (counter==0) {  // 最初の点のみ
              ctx.moveTo(
                point_dict["x"],
                point_dict["y"]
              );
            } else {  // 最初の点・最後の点以外
              ctx.lineTo(
                point_dict["x"],
                point_dict["y"]
              );
            } 
            counter ++;
          }
          ctx.lineTo(
            offset_x,
            offset_y
            );
          ctx.strokeStyle = "blue";
          ctx.stroke();
        }
      }

      function draw_points(offset_x, offset_y) {
        if (is_roi_polygon_closed) { // ポリゴンが閉じている場合
          for (var index in roi_polygon_pos_list) {
            var point_dict = roi_polygon_pos_list[index];
            if (index==roi_point_index && offset_x!=null && offset_y!=null) {
              ctx.beginPath();
              ctx.arc(offset_x, offset_y, 2, 0, 2*Math.PI, false);
              ctx.fillStyle = "red";
              ctx.fill();
            } else if (index!=(roi_polygon_pos_list.length-1)) {  // 最初の点・最後の点(最初の点と同じ)以外
              ctx.beginPath();
              ctx.arc(point_dict["x"], point_dict["y"], 2, 0, 2*Math.PI, false);
              ctx.fillStyle = "red";
              ctx.fill();
            }
          }
        } else { // ポリゴンが閉じていない場合
          for (var index in roi_polygon_pos_list) {
            var point_dict = roi_polygon_pos_list[index];
            ctx.beginPath();
            ctx.arc(point_dict["x"], point_dict["y"], 2, 0, 2*Math.PI, false);
            ctx.fillStyle = "blue";
            ctx.fill();
          }
          if (offset_x!=null && offset_y!=null){
            ctx.beginPath();
            ctx.arc(offset_x, offset_y, 2, 0, 2*Math.PI, false);
            ctx.fillStyle = "blue";
            ctx.fill();    
          }
        }
      }

      function onMove(e) {
        var offsetX = e.offsetX; // =>要素左上からのx座標
        var offsetY = e.offsetY; // =>要素左上からのy座標
        clear_canvas();
        draw_polygon(offsetX, offsetY);
        draw_points(offsetX, offsetY);
      }

      canvas.addEventListener("click", onLeftClick)
      //canvas.addEventListener("contextmenu", onRightClick)
      canvas.oncontextmenu = onRightClick // なぜかaddEventListenerだとうまく行かない
      canvas.addEventListener("mousemove", onMove)

    </script>
  </body>
</html>